package com.ahmetkizilay.yatlib4j.oauthhelper;

import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Random;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;

import com.ahmetkizilay.yatlib4j.utils.GenericUtils;
import com.ahmetkizilay.yatlib4j.utils.SortableKeyValueList;
import com.ahmetkizilay.yatlib4j.utils.SortableKeyValuePair;

public final class OAuthUtils {
	private static final String OAUTH_SIGNATURE_METHOD = "HMAC-SHA1";
	private static final String DEFAULT_OAUTH_VERSION = "1.0";
	
	public static String generateTimeStamp() {
		return Long.toString(System.currentTimeMillis() / 1000);
	}
	
	public static String generateNonce() {
		// FROM THE DOCUMENTATION
		// The value for this request was generated by base64 encoding 32 bytes of random data, and stripping out all non-word characters, 
		// but any approach which produces a relatively random alphanumeric string should be OK here.
		
		// so for laziness, I just produce 42 bytes of random data and convert it to hex
		
		byte[] randomBytes = new byte[21]; 
		new Random().nextBytes(randomBytes);
		return GenericUtils.convertToHexString(randomBytes); 
	}
	
	public static String generateSignInWithTwitterRequestHeader(String httpMethod, String baseHttpUrl, OAuthRequestParams oauthReqParams) {
		String oauth_timestamp = OAuthUtils.generateTimeStamp();
		String oauth_nonce = OAuthUtils.generateNonce();
		
		SortableKeyValueList sortableListWrapper = new SortableKeyValueList();
		sortableListWrapper.add("oauth_callback", oauthReqParams.getOAuthCallback());
		sortableListWrapper.add("oauth_consumer_key", oauthReqParams.getConsumerKey());
		sortableListWrapper.add("oauth_nonce", oauth_nonce);		
		sortableListWrapper.add("oauth_signature_method", "HMAC-SHA1");
		sortableListWrapper.add("oauth_timestamp", oauth_timestamp);
		sortableListWrapper.add("oauth_version", "1.0");

		
		ArrayList<SortableKeyValuePair> pairList = sortableListWrapper.getList();
		String oauthSignature = "";
		try {
			String parameterString = OAuthUtils.buildParameterString(pairList);
			
			String signatureBaseString = OAuthUtils.buildSignatureBaseString(httpMethod, baseHttpUrl, parameterString);
			
			oauthSignature = OAuthUtils.calculateOAuthSignature(oauthReqParams.getConsumerSecret(), "", signatureBaseString);
		}
		catch(Exception exp) {
			exp.printStackTrace();
			return null;
		}
		
		StringBuffer headerBuffer = new StringBuffer();
		headerBuffer.append("OAuth ");
		headerBuffer.append("oauth_callback=\"" + oauthReqParams.getOAuthCallback() + "\", ");
		headerBuffer.append("oauth_consumer_key=\"" + oauthReqParams.getConsumerKey() + "\", ");
		headerBuffer.append("oauth_nonce=\"" + oauth_nonce + "\", ");
		headerBuffer.append("oauth_signature=\"" + oauthSignature + "\", ");
		headerBuffer.append("oauth_signature_method=\"" + OAUTH_SIGNATURE_METHOD + "\", ");
		headerBuffer.append("oauth_timestamp=\"" + oauth_timestamp + "\", ");
		headerBuffer.append("oauth_version=\"" + DEFAULT_OAUTH_VERSION + "\"");

		return headerBuffer.toString();		
	}
	
	public static String generateAppOnlyAuthHeader(String consumerKey, String consumerSecret) {
		try {
			String bearerTokenCredential = GenericUtils.percentEncode(consumerKey) + ":" + GenericUtils.percentEncode(consumerSecret);
			String bearerTokenB64 = GenericUtils.base64Encode(bearerTokenCredential.getBytes("UTF-8"));
			
			StringBuffer headerBuffer = new StringBuffer();
			headerBuffer.append("Basic ");
			headerBuffer.append(bearerTokenB64);

			return headerBuffer.toString();					
		}
		catch(Exception exp) {
			return null;
		}
		
 	}
	public static String generateOAuthHeader(String httpMethod, String baseHttpUrl, Hashtable<String, String> httpParams, OAuthHolder oauthHolder) {
		
		String oauth_timestamp = OAuthUtils.generateTimeStamp();
		String oauth_nonce = OAuthUtils.generateNonce();
		
		SortableKeyValueList sortableListWrapper = new SortableKeyValueList();
		sortableListWrapper.add("oauth_signature_method", "HMAC-SHA1");
		sortableListWrapper.add("oauth_version", "1.0");

		sortableListWrapper.add("oauth_consumer_key", oauthHolder.getConsumerKey());
		sortableListWrapper.add("oauth_nonce", oauth_nonce);		
		sortableListWrapper.add("oauth_timestamp", oauth_timestamp);
		sortableListWrapper.add("oauth_token", oauthHolder.getOAuthToken());
		
		for(Enumeration<String> httpParamKeys = httpParams.keys(); httpParamKeys.hasMoreElements();) {
			String key = httpParamKeys.nextElement();
			sortableListWrapper.add(key, httpParams.get(key));
		}
		
		ArrayList<SortableKeyValuePair> pairList = sortableListWrapper.getList();
		String oauthSignature = "";
		try {
			String parameterString = OAuthUtils.buildParameterString(pairList);
			
			String signatureBaseString = OAuthUtils.buildSignatureBaseString(httpMethod, baseHttpUrl, parameterString);
			
			oauthSignature = OAuthUtils.calculateOAuthSignature(oauthHolder.getConsumerSecret(), oauthHolder.getOAuthTokenSecret(), signatureBaseString);
		}
		catch(Exception exp) {
			exp.printStackTrace();
			return null;
		}
		
		StringBuffer headerBuffer = new StringBuffer();
		headerBuffer.append("OAuth ");
		headerBuffer.append("oauth_consumer_key=\"" + oauthHolder.getConsumerKey() + "\", ");
		headerBuffer.append("oauth_nonce=\"" + oauth_nonce + "\", ");
		headerBuffer.append("oauth_signature=\"" + oauthSignature + "\", ");
		headerBuffer.append("oauth_signature_method=\"" + OAUTH_SIGNATURE_METHOD + "\", ");
		headerBuffer.append("oauth_timestamp=\"" + oauth_timestamp + "\", ");
		headerBuffer.append("oauth_token=\"" + oauthHolder.getOAuthToken() + "\", ");
		headerBuffer.append("oauth_version=\"" + DEFAULT_OAUTH_VERSION + "\"");

		return headerBuffer.toString();		
	}
	
	private static String buildParameterString(ArrayList<SortableKeyValuePair> sortedPairs) throws Exception {		
		StringBuffer sb = new StringBuffer();
		for(int i = 0; i < sortedPairs.size(); ++i) {
			SortableKeyValuePair thisPair = sortedPairs.get(i);
			sb.append(GenericUtils.percentEncode(thisPair.key));
			sb.append("=");
			sb.append(GenericUtils.percentEncode(thisPair.value));
			sb.append("&");
		}
				
		sb.setLength(sb.length() - 1);
		return sb.toString();
	}
	
	private static String buildSignatureBaseString(String httpMethod, String httpUrl, String parameterString) throws Exception {		
		StringBuilder sb = new StringBuilder();
		sb.append(httpMethod.toUpperCase());
		sb.append("&");
		sb.append(GenericUtils.percentEncode(httpUrl));
		sb.append("&");
		sb.append(GenericUtils.percentEncode(parameterString));
		return sb.toString();
	}
		
	private static String calculateOAuthSignature(String consumerSecret, String oauthTokenSecret, String signatureBaseString) throws Exception {		
		String key = consumerSecret + "&" + oauthTokenSecret;
		SecretKeySpec signingKey = new SecretKeySpec(key.getBytes("UTF-8"), "HmacSHA1");

		Mac mac = Mac.getInstance("HmacSHA1");
		mac.init(signingKey);

		byte[] rawHmac = mac.doFinal(signatureBaseString.getBytes("UTF-8"));

		return GenericUtils.percentEncode(GenericUtils.base64Encode(rawHmac));
	}
}
